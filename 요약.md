# 요약

## 1장

### 스프링 주요 특징

- 의존 주입 지원
- AOP 지원
- MVC 웹 프레임워크 제공
- JDBC, JPA 연동, 트랜잭션 처리 지원



## 2장

- `@Configuration` 애노테이션은 해당 클래스를 **스프링 설정 클래스로 지정한다**
- `@Bean` 애노테이션을 메서드에 붙이면 **해당 메서드가 생성한 객체를 스프링이 관리하는 빈 객체로 등록한다**

- `AnnotationConfigApplicationContext` 클래스는 자바 설정에서 정보를 읽어와 빈 객체를 생성하고 관리한다

- `ApplicationContext` 또는 `BeanFactory`는 빈 객체의 생성, 초기화, 보관, 제거 등을 관리한다
  - 그래서 **컨테이너(Container)**라고도 부른다, **스프링 컨테이너**



## 3장

- 의존 : 객체간의 의존을 의미
- **스프링이 어떤 객체를 생성하고, 의존을 어떻게 주입할지 정의한 설정 정보를 작성해야 된다**

```java
package config;

...

@Configuration
public class AppCtx {
	
	@Bean
	public MemberDao memberDao() {
		return new MemberDao();
	}
	
	@Bean
	public MemberRegisterService memberRegSvc() {
		return new MemberRegisterService(memberDao());
	}
	
	@Bean
	public ChangePasswordService changePwdSvc() {
		ChangePasswordService pwdSvc = new ChangePasswordService();
		pwdSvc.setMemberDao(memberDao());
		return pwdSvc;
	}
}
```

### DI 주입 방식

1. 생성자로 주입

   ```java
   @Configuration
   public class AppCtx {
   	
   	@Bean
   	public MemberDao memberDao() {
   		return new MemberDao();
   	}
   	
   	...
   	
   	@Bean
   	public MemberPrinter memberPrinter() {
   		return new MemberPrinter();
   	}
   	
   	@Bean
   	public MemberListPrinter listPrinter() {
   		return new MemberListPrinter(memberDao(), memberPrinter());	// 의존 객체 주입
   	}
   }
   ```

2. setter, getter로 주입

   ```java
   @Configuration
   public class AppCtx {
   	...
   	@Bean
   	public MemberInfoPrinter infoPrinter() {
   		MemberInfoPrinter infoPrinter = new MemberInfoPrinter();
   		infoPrinter.setMemberDao(memberDao());
   		infoPrinter.setPrinter(memberPrinter());
   		return infoPrinter;
   	}
   }
   ```

   

- **`@Autowired` 애노테이션**은 **스프링의 자동 주입 기능**을 위한 것

  - **해당 타입의 빈을 찾아서 필드에 할당한다**

  ```java
  public class MemberInfoPrinter {
      @Autowired							//@Autowired 붙임
  	private MemberDao memDao;
      @Autowired
  	private MemberPrinter printer;
  	
  	public void printMemberInfo(String email) {
  		Member member = memDao.selectByEmail(email);
  		
  		if(member==null) {
  			System.out.println("데이터 없음\n");
  			return;
  		}
  		printer.print(member);
  		System.out.println();
  	}
  
  	...
  	
  }
  ```

  - 두 필드에 `@Autowired` 애노테이션 붙였다

  - **`@Autowired` 애노테이션을 의존 주입 대상에 붙이면 스프링 설정 클래스의 `@Bean` 메서드에 의존 주입을 위한 코드를 작성하지 않아도 된다**

    ```java
    @Bean
    public MemberInfoPrinter infoPrinter(){
        MemberInfoPrinter infoPrinter = new MemberInfoPrinter();
        //infoPrinter.setMemberDao(memberDao());
    	//infoPrinter.setPrinter(memberPrinter());
        // 세터를 통해 의존 주입하지 않아도 스프링 컨테이너가 @Autowired를 붙인 필드에 자동으로 해당 타입의 빈 객체를 주입
        return infoPrinter
    }
    ```

- `@Import` : 두 개 이상의 설정 파일을 사용하는 또 다른 방법

  ```java
  @Configuration
  @Import({AppConf1.class, AppConf2.class})
  public class AppConfImport{
      
  }
  ```



## 4. 의존 자동 주입

- 자동 주입

  ```java
  @Configuration
  public class AppCtx {
  	
  	@Bean
  	public MemberDao memberDao() {
  		return new MemberDao();
  	}
  	
  	@Bean
  	public ChangePasswordService changePwdSvc() {
  		ChangePasswordService pwdSvc = new ChangePasswordService();
  		//pwdSvc.setMemberDao(memberDao());		// 의존 주입을 안해도 의존 객체가 주입된다
  		return pwdSvc;
  	}
  	
  }
  ```

  ```java
  public class ChangePasswordService {
  	@Autowired		//@Autowired 붙임
  	private MemberDao memberDao;
  	
  	public void changePassword(String email, String oldPwd, String newPwd) {
  		Member member = memberDao.selectByEmail(email);
  		
  		if(member == null)
  			throw new MemberNotFoundException();
  		
  		member.changePassword(oldPwd, newPwd);
  		
  		memberDao.update(member);
  	}
  	
  	public void setMemberDao(MemberDao memberDao) {
  		this.memberDao = memberDao;
  	}
  }
  ```

- **의존을 주입할 대상에 `@Autowired` 애노테이션을 붙이면 된다**



- `@Autowired`는 메서드에도 붙일 수 있다

  - 빈 객체의 메서드에 `@Autowired`를 붙이면 스프링은 해당 메서드를 호출한다
    - 메서드 파라미터 타입에 해당하는 빈 객체를 찾아 인자로 주입한다
    - 예시 코드에서 메서드 파라미터로, 빈 객체 `memberDao`, `printer`가 있다

  ```java
  public class MemberInfoPrinter {
  	private MemberDao memDao;
  	private MemberPrinter printer;
  	
  	public void printMemberInfo(String email) {
  		Member member = memDao.selectByEmail(email);
  		
  		if(member==null) {
  			System.out.println("데이터 없음\n");
  			return;
  		}
  		printer.print(member);
  		System.out.println();
  	}
  	
  	@Autowired		// 추가
  	public void setMemberDao(MemberDao memberDao) {
  		this.memDao = memberDao;
  	}
  
      @Autowired		// 추가
  	public void setPrinter(MemberPrinter printer) {
  		this.printer = printer;
  	}
  	
  }
  ```



- 자동 주입이 가능한 빈이 두 개 이상인 경우 **자동 주입할 빈을 지정할 수 있도록**

  - **`@Qualifier` 애노테이션을 사용한다**
  - 자동 주입 대상을 한정할 수 있다

  ```java
  	@Bean
  	@Qualifier("printer")
  	public MemberPrinter memberPrinter1() {
  		return new MemberPrinter();
  	}
  
  	@Bean
  	public MemberPrinter memberPrinter2() {
  		return new MemberPrinter();
  	}
  ```

  - 혹은 **자동 주입할 빈을 한정할 때 사용**

  ```java
  public class MemberListPrinter {
  	private MemberDao memberDao;
  	private MemberPrinter printer;
  	
  	...
  
  	@Autowired
      @Qualifier("printer")
  	public void setMemberPrinter(MemberPrinter printer) {
  		this.printer = printer;
  	}
  	
  }
  ```

  

- **자동 주입에서 NULL 처리 방법** => 4장 md파일 확인



## 5장 - 컴포넌트 스캔

- `컴포넌트 스캔`은 **스프링이 직접 클래스를 검색해서 빈으로 등록해주는 기능**
  - **설정 클래스에 빈으로 등록하지 않아도** 원하는 클래스를 빈으로 등록할 수 있다

- `@Component` 애노테이션으로 스프링이 검색해서 **빈으로 등록할 수 있도록** 한다

  - **해당 클래스를 스캔 대상으로 표시**한다

  ```java
  @Component		// 붙임
  public class MemberDao {
  	private static long nextId = 0;
  	
  	private Map<String, Member> map = new HashMap<>();
  	
  	public Member selectByEmail(String email) {
  		return map.get(email);
  	}
  	
  	...
  }
  ```

- `@Component` 애노테이션을 붙인 **클래스를 스캔해서 스프링 빈으로 등록하려면** **설정 클래스에 `@ComponentScan` 애노테이션을 적용해야 된다**

> - @Component(org.springframework.stereotype 패키지)
> - @Controller(org.springframework.stereotype 패키지)
> - @Service(org.springframework.stereotype 패키지)
> - @Repository(org.springframework.stereotype 패키지)
> - @Aspect(org.aspectj.lang.annotation 패키지)
> - @Configuration(org.springframework.context.annotation 패키지)



- **스캔 대상 제외, 빈 충돌 처리는 5장 md 확인**



## 6장 - 빈 라이프사이클과 범위

1. `AnnotationConfigApplicationContext`의 생성자를 통해 컨텍스트 객체를 생성한다

   - 이 시점에 스프링 컨테이너를 초기화한다

   - **스프링 컨테이너는 설정 클래스에서 정보를 읽어와 알맞은 빈 객체를 생성하고 각 빈을 연결(의존 주입)하는 작업 수행**
2. 컨테이너를 사용
   - `getBean()`과 같은 메서드를 이용해 **컨테이너에 보관된 빈 객체**를 구한다
3. 컨테이너 종료
   - `close()` 메서드는 `AbstractApplicationContext` 클래스에 정의되어 있다



- 스프링 컨테이너는 빈 객체의 라이프사이클을 관리한다

  > **[객체 생성] => [의존 설정] => [초기화] => [소멸]**



- 빈 객체가 `InitializingBean` 인터페이스를 구현하면 스프링 컨테이너는 초기화 과정에서 빈 객체의 `afterPropertiesSet()` 메서드를 실행한다

  - 빈 객체 생성 뒤, 초기화가 필요하면 `InitializingBean` 인터페이스를 상속하고 `afterPropertiesSet()` 메서드를 알맞게 구현하면 된다

- 스프링 컨테이너는 빈 객체가 `DisposableBean` 인터페이스를 구현한 경우 소멸 과정에서 빈 객체의 `destroy()` 메서드를 실행한다

  - 빈 객체의 소멸 과정이 필요하면 `DisposableBean` 인터페이스를 상속하고 `destroy()` 메서드를 알맞게 구현하면 된다

  ```java
  public class Client implements InitializingBean, DisposableBean {
  
  	private String host;
  	
  	public void setHost(String host) {
  		this.host = host;
  	}
  	
  	@Override
  	public void afterPropertiesSet() throws Exception {
  		System.out.println("Client.afterPropertiesSet() 실행");
  	}
  	
  	public void send() {
  		System.out.println("Client.send() to "+host);
  	}
  	
  	@Override
  	public void destroy() throws Exception {
  		System.out.println("Client.destroy() 실행");
  	}
  
  }
  
  //main 실행하면
  /*
  ...
  Client.afterPropertiesSet() 실행
  Client.send() to host
  Client.destroy() 실행
  ```

- **두 인터페이스를 구현할 수 없거나, 사용하고 싶지 않은 경우 스프링 설정에서 직접 메서드를 지정할 수 있다**

  - `@Bean` 태그에서 `initMethod` 속성과 `destroyMethod` 속성을 사용

  ```java
  public class Client2 {		// 인터페이스 구현안함!!!
  	
  	private String host;
  
  	public void setHost(String host) {
  		this.host = host;
  	}
  	
  	public void connect() {
  		System.out.println("Client2.connect() 실행");
  	}
  	
  	public void send() {
  		System.out.println("Client2.send() 실행");
  	}
  	
  	public void close() {
  		System.out.println("Client2.close() 실행");
  	}
  }
  ```

  ```java
  @Bean(initMethod = "connect", destroyMethod = "close")		// 직접 설정한 메서드
  public Client2 client2() {
  	Client2 client2 = new Client2();
  	client2.setHost("host");
  	return client2;
  }
  ```

  

- 프로토타입 범위의 빈을 설정할 수 있다(사용 빈도 낮음)

  > - 프로토타입 빈 객체 사용시 소멸 처리를 코드에서 직접 해야된다

  - 빈의 범위를 프로토타입으로 지정하면 **빈 객체를 구할 때마다 새로운 객체를 생성한다** (더이상 싱글톤이 아니게됨)

  ```java
  @Configuration
  public class AppCtxWithPrototype {
  	
  	@Bean
  	@Scope("prototype")
  	public Client client() {
  		Client client = new Client();
  		client.setHost("host");
  		return client;
  	}
  }
  ```

  



## 7장 - AOP

- **`프록시(proxy)`** : **핵심 기능의 실행은 다른 객체에 위임하고 부가적인 기능을 제공하는 객체**
  - 핵심 기능을 구현하지 않는 대신 **여러 객체에 공통으로 적용 가능한 기능을 구현**

- AOP(Aspect Oriented Programming) : 여러 객체에 공통으로 적용할 수 있는 기능을 분리해서 재사용성을 높여주는 프로그래밍 기법
  - 핵심 기능과 공통 기능의 구현을 분리하여 **핵심 기능을 구현한 코드의 수정 없이 공통 기능을 적용**할 수 있게 한다

- 스프링 AOP를 이용해 공통 기능을 구현하고 적용하는 방법

  1. Aspect로 사용할 클래스에 `@Aspect` 애노테이션을 붙인다
  2. `@Pointcut` 애노테이션으로 공통 기능을 적용한 `Pointcut`을 정의한다
  3. 공통 기능을 구현한 메서드에 `@Around` 애노테이션을 적용한다

  ```java
  @Aspect
  public class ExeTimeAspect {
  	
  	@Pointcut("execution(public * chap07..*(..))")		// 공통 기능 적용할 대상 설정
  	private void publicTarget() {}
  	
  	@Around("publicTarget()")
  	public Object measure(ProceedingJoinPoint joinPoint) throws Throwable{
  		
  		long start = System.nanoTime();
  		
  		try {
  			Object result = joinPoint.proceed();		//객체의 메서드 호출
  			return result;
  		} finally {
  			long finish = System.nanoTime();
  			Signature sig = joinPoint.getSignature();
  			System.out.printf("%s.%s(%s) 실행 시간 : %d ns\n",
  					joinPoint.getTarget().getClass().getSimpleName(),
  					sig.getName(), Arrays.toString(joinPoint.getArgs()),
  					(finish-start));
  		}
  	}
  }
  ```

  - `Around Advice`에서 사용할 공통 기능 메서드는 대부분 파라미터로 전달받은 `ProceedingJoinPoint`의 `proceed()` 메서드만 호출하면 된다

- 스프링 설정 클래스 작성

  - `@Aspect`을 붙인 클래스를 **공통 기능으로 적용하려면 `@EnableAspectJAutoProxy`를 설정 클래스에 붙여야 된다**
    - 스프링이 `@Aspect`가 붙은 빈 객체를 찾아 `@Pointcut` 설정과 `@Around` 설정을 사용한다

  ```java
  @Configuration
  @EnableAspectJAutoProxy		//붙임
  public class AppCtx {
  
  	@Bean
  	public ExeTimeAspect exeTimeAspect() {		//위 코드의 @Aspect 붙은 클래스
  		return new ExeTimeAspect();
  	}
  	
  	@Bean
  	public Calculator calculator() {		//chap07 패키지에 속한 타입 ==> ExeTimeAspect에 있는 공통 기능이 적용된다
  		return new RecCalculator();
  	}
  }
  ```

  